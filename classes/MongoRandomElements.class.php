<?php
/**
 *  MongoRandomElements.class.php
 *  File with the class used to generate random elements and save then in MongoDB (users, URL's ...)
 *  @author JosÃ© Manuel Ciges Regueiro <jmanuel@ciges.net>, Web page {@link http://www.ciges.net}
 *  @license http://www.gnu.org/copyleft/gpl.html GNU GPLv3
 *  @version 20121102
 *
 *  @package InternetAccessLog
 *  @filesource
 */
require_once("RandomElements.class.php");
 /**
 *  This class is used to generate random elements (users, IP's and URL's) and save them into MongoDB
 *  With this elements created we can simulate non FTP and FTP log entries (in our demo the acces by FTP are stored in a separate collection)
 */
 class MongoRandomElements extends RandomElements	{
 
    /**#@+
	 *  Default names for random data collections
     */
	const RNDUSERSC_NAME = "Random_UsersList";
	const RNDIPSC_NAME = "Random_IPsList";
	const RNDDOMAINSC_NAME = "Random_DomainsList";
    const NONFTPLOG_NAME = "NonFTP_Access_log";
    const FTPLOG_NAME = "FTP_Access_log";
    /**#@-*/
    
    /**#@+
     *  Default prefixes for monthly reports
     */
    const USERS_REPORT_PREFIX = "Users_Monthly_Report_";
	const DOMAINS_REPORT_PREFIX = "Domains_Monthly_Report_";
	/**#@-*/
    
    /**#@+
     * Constants for default connection values
     */
    const DEFAULT_USER = "mongodb";
    const DEFAULT_PASSWORD = "mongodb";
    const DEFAULT_HOST = "localhost";
    const DEFAULT_DB = "InternetAccessLog";
    const DEFAULT_SAFEMODE = false;
	/**#@-*/
    
    /**
     * Connection to the database
     * @access private
     * @var Mongo
     */
    private $db_conn;
    /**
     * Database name
     * @access private
     * @var Mongo
     */
    private $db_databasename;
    
    /**#@+
     * Number of element of each created collection in MongoDB (for cache purposes)
     * @access private
     * @var string
     */
	private $rnd_users_number;
	private $rnd_ips_number;
	private $rnd_domains_number;
    /**#@-*/

    /** 
    *  This function queries the database to return the users number (records in Random_UsersList)
    *  @return integer
    *  @access public
    */
    public function getUserNumber() {
        $this->rnd_users_number = $this->getUserCollection()->count();
        return $this->rnd_users_number;
    }

    /**
     *  This function returns the username searching by the id
     *  @param integer $userid
     *  @return string $username
     *  @access public
     */
    public function getUserFromID($userid) {
        $cursor = $this->getUserCollection()->find(array('_id' => $userid));
        if ($cursor->hasNext()) {
            $row = $cursor->getNext();
            return $row['user'];
        }
    }
    
    /**
     *  This function returns the user data from the reports for a year and month specified. If there is no data returns null
     *  @param string $username
     *  @param integer $year
     *  @param integer $month   Number from 1 to 12
     *  @return array
     *  @access public
     */
    public function getUserCollectedData($username, $year, $month)  {
        $col = self::USERS_REPORT_PREFIX.$year.sprintf("%02d", $month);
        $cursor = $this->getDB()->$col->find(array('_id' => $username));
        if ($cursor->hasNext()) {
            return $cursor->getNext();
        }
    }
    
    /**
     *  This function add a fake user to the collection passed as second argument. If not collection done then the user will be added to Random_UsersList.
     *  This function is coded for load tests, not for real user. The id is the id generated by Mongo
     *  Returns true if the user has been succesfull added, false if not
     *  @param string $username
     *  @param string $collectionname
     *  @access public
     *  @return boolean
     */
    public function addFakeUser($username, $collectionname = self::RNDUSERSC_NAME)   {
        $user_col = $this->getDB()->$collectionname;
        try {
            $doc = array("user" => $username);
            $user_col->insert($doc, array("safe" => $this->safemode));
            return true;
        }
        catch (MongoConnectionException $e) {
            return false;
        }
    }
    
    /**
     *  This function verifies if the user exists in the collection passed as second argument. If not collection done then the user will be added to Random_UsersList.
     *  @param string $username
     *  @param string $tablename
     *  @return boolean
     *  @access public
     */
    public function existUser($username, $collectionname = self::RNDUSERSC_NAME)    {
        $cursor = $this->getDB()->$collectionname->find(array('user' => $username))->limit(1); 
        $cursor->count() > 0;
    }
    
    /**
     *  Constructor. For creating an instance we need to pass all the parameters for the MongoDB database where the data will be stored (user, password, host & database name). The fifth parameter tells if the insertions will we made in safe mode or not (by default they are NOT safe)
     *  <ul>
     *  <li>The default user and password will be mongodb
     *  <li>The default host will be localhost
     *  <li>The default database name will be InternetAccessLog
     *  <li>Inertions will be NOT safe by default
     *  </ul>
     *  @param string $user
     *  @param string $password
     *  @param string $host
     *  @param string $database
     *  @param boolean $safemode
	 */
	function __construct($user = self::DEFAULT_USER, $password = self::DEFAULT_PASSWORD, $host = self::DEFAULT_HOST, $database = self::DEFAULT_DB, $safemode = self::DEFAULT_SAFEMODE)	{
		// Open a connection to MongoDB
		try {
			$this->db_conn = new Mongo("mongodb://".$user.":".$password."@".$host."/".$database);
            $this->db_databasename = $database;
		}
		catch (MongoConnectionException $e) {
			die("Connection to MongoDB impossible: (".$e->getCode().") ".$e->getMessage()."\n");
		}
		
		// Stores the number of elements of each stored random elements collection
        $db = $this->db_databasename;
        $this->safemode = $safemode;
        $userscol_name = self::RNDUSERSC_NAME;
        $ipscol_name = self::RNDIPSC_NAME;
        $domainscol_name = self::RNDDOMAINSC_NAME;
        $nonftp_log_name = self::NONFTPLOG_NAME;
        $ftp_log_name = self::FTPLOG_NAME;
		$this->rnd_users_number =  $this->db_conn->$db->$userscol_name->count();
		$this->rnd_ips_number = $this->db_conn->$db->$ipscol_name->count();
		$this->rnd_domains_number = $this->db_conn->$db->$domainscol_name->count();
	}

    /**
     *  Destructor. Close the open connection to MongoDB database
 	 */
	function __destruct()	{
		$this->db_conn->close();
	}
    
    /**
     *  Get the connection created to the database (the db, not the server)
     *  @return MongoDB
     */
     public function getDB()    {
        $databasename = $this->db_databasename;
        return $this->db_conn->$databasename;
     }
 
    /**
     *  Sends an aggregation array of commands to the database and returns the results (array of documents). If no documents are got null is returned
     *  @param array $pipeline
     *  @param string $collection
     *  @return array
     *  @access public
     */
    public function getResults($pipeline, $collection = "NonFTP_Access_log")    {
        $db = $this->getDB();
        MongoCursor::$timeout = -1;         
        $data = $this->getDB()->command (
            array(
                "aggregate" => $collection,
                "pipeline" => $pipeline
            ));
        return $data['result'];
    }
     
    /**
     *  Sends an aggregation array of commands to the database and returns the first document. If no documents are got null is returned
     *  @param array $pipeline
     *  @param string $collection
     *  @return array
     *  @access public
     */
    public function getRow($pipeline, $collection = "NonFTP_Access_log")    {        
        $data = $this->getResults($pipeline, $collection);
        return $data[0];
    }

    /**
     *  Sends an aggregation array of commands to the database and returns the field '_id' of the first document. If no documents are got null is returned
     *  @param array $pipeline
     *  @param string $collection
     *  @return array
     *  @access public
     */
    public function getOne($pipeline, $collection)    {
        $row = $this->getRow($pipeline, $collection);
        return $row['_id'];
    }
 
    /**
     *  Get a link to the users collectioc
     *  @return MongoCollection
     */
    public function getUserCollection() {
        $user_col_name = MongoRandomElements::RNDUSERSC_NAME;
        return $this->getDB()->$user_col_name;
    }
    
    /**
     *  Save random users in MongoDB.  
     *  The parameters are the number of users to create and to booleans: if we want an unique index to be created for the user name (default is TRUE) and if we want that the user name is unique (default TRUE). 
     *  If the user name is going to be unique the existence of the name is verified with a query before inserting a new one.
     *  The id will be autonumeric (1, 2, 3 ....)
	 *  @param integer $number
     *  @param boolean $use_index
     *  @param boolean $dont_repeat
     */
	function createUsers($number, $use_index = TRUE, $dont_repeat = TRUE)	{
		$id = $this->rnd_users_number + 1;   // Autonumeric
        
        $db = $this->db_databasename;      
        $col_name = self::RNDUSERSC_NAME;
        $col = $this->db_conn->$db->$col_name;
        
        if ($use_index) {
            $col->ensureIndex(array('user' => 1), array("unique" => true));	// Unique index for the 'user' field
        }
        $i = 1;
		while ($i <= $number)	{
			$user = $this->getRandomUser();
            // We verify if the user is in the collection only if it is needed
            $insert = TRUE;
            if ($dont_repeat) {
                $cursor = $col->find(array("user" => $user))->limit(1);
                if ($cursor->count() > 0)  {
                    $insert = FALSE;
                }
            }
            if ($insert)   {
                try {
                    $col->insert(array("_id" => $id, "user" => $user), array("safe" => $this->safemode));
                    $id++;
                }
                catch (MongoConnectionException $e) {
                    die("Save of user document in MongoDB not possible: (".$e->getCode().") ".$e->getMessage()."\n");
                }
                $i++;
            }
		}
        $this->rnd_users_number = $col->count();
	}
    
    /**
     *  Returns true if the random users collection has at least one user
     *  @return boolean
     */
	function randomUsers_exists()	{
        $db = $this->db_databasename;
        $col = self::RNDUSERSC_NAME;
        $this->db_conn->$db->$col->count() > 0 ? true : false;
	}

    /**
     *  Save random IPs in MongoDB
     *  The parameters are the number of IPs to create and to booleans: if we want an unique index to be created for the ip (default is TRUE) and if we want that the ip is unique (default TRUE). 
     *  If the ip is going to be unique the existence of the name is verified with a query before inserting a new one
     *  The id will be autonumeric (1, 2, 3 ....)
     *  @param integer $number
     *  @param boolean $use_index
     *  @param boolean $dont_repeat_users
     */
	function createIPs($number, $use_index = TRUE, $dont_repeat = TRUE)	{
		$id = $this->rnd_ips_number + 1;   // Autonumeric
        
        $db = $this->db_databasename;      
        $col_name = self::RNDIPSC_NAME;
        $col = $this->db_conn->$db->$col_name;
        
        if ($use_index) {
            $col->ensureIndex(array('ip' => 1), array("unique" => true));	// Unique index for the 'ip' field
        }
        $i = 1;
		while ($i <= $number)	{
			$ip = $this->getRandomIP();
            // We verify if the user is in the collection only if it is needed
            $insert = TRUE;
            if ($dont_repeat) {
                $cursor = $col->find(array("ip" => $ip))->limit(1);
                if ($cursor->count() > 0)  {
                    $insert = FALSE;
                }
            }
            if ($insert)   {
				try {
					$col->insert(array("_id" => $id, "ip" => $ip), array("safe" => $this->safemode));
                    $id++;
				}
				catch (MongoConnectionException $e) {
					die("Save of IP document in MongoDB not possible: (".$e->getCode().") ".$e->getMessage()."\n");
				}
				$i++;
			}
		}	
        $this->rnd_ips_number = $col->count();
	}	
    
    /**
     *  Returns true if the IPs collection has at least one IP
     *  @return boolean
     */
	function randomIPs_exists()	{
        $db = $this->db_databasename;
        $col = self::RNDIPSC_NAME;
        $this->db_conn->$db->$col->count() > 0 ? true : false;
	}

    /**
     *  Save random domains in MongoDB
     *  The parameter are the number of domains to create and to booleans: if we want an unique index to be created for the domain (default is TRUE) and if we want that the domain is unique (default TRUE). 
     *  If the domain is going to be unique the existence of the name is verified with a query before inserting a new one
     *  The id will be autonumeric (1, 2, 3 ....)
     *  @param integer $number
     *  @param boolean $use_index
     *  @param boolean $dont_repeat_users
     */
	function createDomains($number, $use_index = TRUE, $dont_repeat = TRUE)	{
        $id = $this->rnd_domains_number + 1;   // Autonumeric
        
		$db = $this->db_databasename;      
        $col_name = self::RNDDOMAINSC_NAME;
        $col = $this->db_conn->$db->$col_name;
        
        if ($use_index) {
            $col->ensureIndex(array('domain' => 1), array("unique" => true));	// Unique index for the 'domain' field
        }
        $i = 1;
		while ($i <= $number)	{
			$domain = $this->getRandomDomain();
            // We verify if the user is in the collection only if it is needed
            $insert = TRUE;
            if ($dont_repeat) {
                $cursor = $col->find(array("domain" => $domain))->limit(1);
                if ($cursor->count() > 0)  {
                    $insert = FALSE;
                }   
            }
            if ($insert)   {
				try {
					$col->insert(array("_id" => $id, "domain" => $domain), array("safe" => $this->safemode));
                    $id++;
				}
				catch (MongoConnectionException $e) {
					die("Save of domain document in MongoDB not possible: (".$e->getCode().") ".$e->getMessage()."\n");
				}
				$i++;
			}
		}
        $this->rnd_domains_number = $col->count();
	}
    
    /**
     *  Returns true if the random domains collection has at least one domain
     *  @return boolean
     */
	function randomDomains_exists()	{
		$db = $this->db_databasename;
        $col = self::RNDDOMAINSC_NAME;
        $this->db_conn->$db->$col->count() > 0 ? true : false;
	}

    /**
     *  Returns a random IP from the generated collection
     *  @returns string
     */
	function searchIP()	{
    	$position = mt_rand(1, $this->rnd_ips_number);
        $col = self::RNDIPSC_NAME;
        $cursor = $this->getDB()->$col->find(array('_id' => $position));
        if ($cursor->hasNext()) {
            $row = $cursor->getNext();
            return $row['ip'];
        }
	}
    
    /**
     *  Returns a random user from the generated collection
     *  @return string
     */
	function searchUser()	{
		$position = mt_rand(1, $this->rnd_users_number);
        $db = $this->db_databasename;
        $col = self::RNDUSERSC_NAME;
        $cursor = $this->getDB()->$col->find(array('_id' => $position));
        if ($cursor->hasNext()) {
            $row = $cursor->getNext();
            return $row["user"];
        }
	}
    
    /**
     *  Returns a random HTTP method from the generated collection
     *  @returns string
     */
	function searchHTTPMethod()	{
		return $this->getRandomHTTPMethod();
	}
    
    /**
     *  Returns a random FTP method from the generated collection
     *  @returns string
     */
	function searchFTPMethod()	{
		return $this->getRandomFTPMethod();
	}
	
    /**
     *  Returns a random domain
     *  @returns string
     */
	function searchDomain() {
        $position = mt_rand(1, $this->rnd_domains_number);
        $db = $this->db_databasename;
        $col = self::RNDDOMAINSC_NAME;
        $cursor = $this->getDB()->$col->find(array("_id" => $position));
        if ($cursor->hasNext()) {
            $row = $cursor->getNext();
            return $row["domain"];
        }
	}
	
    /**
     *  Returns a random URI
     *  @returns string
     */
	function searchURI()	{
        return $this->getRandomString(mt_rand(0,100));
	}

    /**
     *  Returns a random size
     *  @returns integer
     */
	function searchSize()	{
		return $this->getRandomSize();
	}

    /**
     *  Returns a random protocol
     *  @returns string
     */
	function searchProtocol()	{
		return $this->getRandomProtocol();
	}
	
    /**
     *  Returns a random return code
     *  @returns integer
     */
	function searchReturnCode()	{
		return $this->getRandomRetourCode();
	}
 
    /**
     *  Return a random log entry for non FTP access (http and tunnel)
     *  It has two optional arguments, initial and final timestamps, if we want to get a random time in log entry created
     *  @param integer $initial_timestamp
     *  @param integer $final_timestamp
     *  @returns array
     */
	function getRandomNonFTPLogEntry()	{
		if (func_num_args() == 2)	{	
			$initial_timestamp = func_get_arg(0);
			$final_timestamp =  func_get_arg(1);
			$ts = mt_rand($initial_timestamp, $final_timestamp);
		}
		elseif (func_num_args() != 0)	{
			$arguments = func_get_args();
			die("Incorrect arguments number in getRrandomSORLogEntry function: ".implode(" ", $arguments)."\n");
		}
		else {
			$ts = time();
		}
		
		$document = array(
			'clientip' => $this->searchIP(),
			'user' => $this->searchUser(),
			'datetime' => $ts,
			'method' => $this->searchHTTPMethod(),
			'protocol' => $this->searchProtocol(),
			'domain' => $this->searchDomain(),
			'uri' => $this->searchURI(),
			'return_code' => $this->searchReturnCode(),
			'size' => $this->searchSize()	// Size is recorded in the database as string
		);
        
        return $document;
    }
    
    /**
     *  Update Users or Domains monthly and daily report
     *  This function is private and is meant to be used each time an access log is processed to have real time statistics
     *  @param string $collection_name
     *  @param string $id document id (user or domain name)
     *  @param timestamp $timestamp
     *  @param integer $volume
     *  @access private
     */
	function saveReport($collection_name, $id, $timestamp, $volume)  {
    
	    $db = $this->db_databasename;
        $col = $this->db_conn->$db->$collection_name;
		# Document creation if it not exists
		try {
            $cursor = $col->find(array("_id" => $id));
			if ($cursor->count() == 0) {
				$col->insert(array('_id' => $id), array("safe" => $this->safemode));
			}
	
			# Updating monthly and daily values
			$day = (int) strftime("%e", $timestamp);
			$col->update(
				array('_id' => $id),
				array('$inc' => array(
					'nb' => 1, 
					'volume' => $volume,
					"daily.$day.nb" => 1,
					"daily.$day.volume" => $volume
					)
				),
				array("safe" => $this->safemode)
			);
		}
		catch (MongoException $e) {
			die("Saving/Updating data to ".$collection_name." collection for id ".$id." not possible: (".$e->getCode().") ".$e->getMessage()."\n");
		}
	}
 
    /**
     *  Receives a log entry and saves the data and, optionally, monthly and daily precalculated values in database.
     *  By default the reports are created. If the second argument is FALSE they will not be generated
     *  The id for the document in Mongo is created automatically by MongoDB (as an ObjectID)
     *
     *  @param array $log_entry log entry as returned by {@link getRandomNonFTPLogEntry}
     *  @param boolean $create_reports
     */
    function saveRandomNonFTPLogEntry($log_entry, $create_reports=TRUE)    {
		$document = $log_entry;
		$document["datetime"] = new MongoDate($log_entry["datetime"]);
		
        $db = $this->db_databasename;
        $nonftp_log_name = self::NONFTPLOG_NAME;
        $col = $this->db_conn->$db->$nonftp_log_name;
		try {
			$col->insert($document, array("safe" => $this->safemode));
		}
		catch (MongoException $e) {
			die("Saving document to SOR_Access_log collection not possible: (".$e->getCode().") ".$e->getMessage()."\n");
		}
		
		# Monthly reports data update
        if ($create_reports)    {
            $timestamp = $log_entry["datetime"];
            $yearmonth = strftime("%Y%m", $timestamp);
            $this->saveReport(self::USERS_REPORT_PREFIX.$yearmonth, $document["user"], $timestamp, $document['size']);
            $this->saveReport(self::DOMAINS_REPORT_PREFIX.$yearmonth, $document["domain"], $timestamp, $document['size']);
        }
        
    }

    /**
     *  Return a random log entry for FTP access. It is very similar to HTTP and tunnel access but with less fields (there is no protocol and return code)
     *  It has two optional arguments, initial and final timestamps, if we want to get a random time in log entry created
     *  @param integer $initial_timestamp
     *  @param integer $final_timestamp
     *  @returns array
     */
	function getRandomFTPLogEntry()	{
		if (func_num_args() == 2)	{	
			$initial_timestamp = func_get_arg(0);
			$final_timestamp =  func_get_arg(1);
			$ts = mt_rand($initial_timestamp, $final_timestamp);
		}
		elseif (func_num_args() != 0)	{
			$arguments = func_get_args();
			die("Incorrect arguments number in getRrandomSORLogEntry function: ".implode(" ", $arguments)."\n");
		}
		else {
			$ts = time();
		}
		
		$document = array(
			'clientip' => $this->searchIP(),
			'user' => $this->searchUser(),
			'datetime' => $ts,
			'method' => $this->searchFTPMethod(),
			'domain' => $this->searchDomain(),
			'uri' => $this->searchURI(),
			'size' => $this->searchSize()	// Size is recorded in the database as string
		);
        
        return $document;
    }
 
    /**
     *  Receives a FTP log entry and saves the data and, optionally, monthly and daily precalculated values in database.
     *  By default the reports are created. If the second argument is FALSE they will not be generated
     *  The id for the document in Mongo is created automatically by MongoDB (as an ObjectID)
     *
     *  @param array $log_entry log entry as returned by {@link getRandomNonFTPLogEntry}
     *  @param boolean $create_reports
     */
    function saveRandomFTPLogEntry($log_entry, $create_reports=TRUE)    {
		$document = $log_entry;
		$document["datetime"] = new MongoDate($log_entry["datetime"]);
		
        $db = $this->db_databasename;
        $nonftp_log_name = self::FTPLOG_NAME;
        $col = $this->db_conn->$db->$nonftp_log_name;
		try {
			$col->insert($document, array("safe" => $this->safemode));
		}
		catch (MongoException $e) {
			die("Saving document to SOR_Access_log collection not possible: (".$e->getCode().") ".$e->getMessage()."\n");
		}
		
		# Monthly reports data update
        if ($create_reports)    {
            $timestamp = $log_entry["datetime"];
            $yearmonth = strftime("%Y%m", $timestamp);
            $this->saveReport(self::USERS_REPORT_PREFIX.$yearmonth, $document["user"], $timestamp, $document['size']);
            $this->saveReport(self::DOMAINS_REPORT_PREFIX.$yearmonth, $document["domain"], $timestamp, $document['size']);
        }
        
    }
    
}
 
?>
